ğŸ—ºï¸ Relaciones en ApplicationDbContext (EF Core)

---

ğŸ”¹ 1. Uno a Muchos (One-to-Many)

ğŸ“Œ DescripciÃ³n: Un registro en una tabla se relaciona con mÃºltiples registros en otra.

ğŸ“¦ Ejemplo: Un Usuario puede tener muchos Pedidos.

ğŸ“Š Esquema:

Usuarios
--------
Id (PK)
Nombre

Pedidos
-------
Id (PK)
UsuarioId (FK)
Fecha

âš™ï¸ ConfiguraciÃ³n EF Core:

modelBuilder.Entity<Usuario>()
    .HasMany(u => u.Pedidos)
    .WithOne(p => p.Usuario)
    .HasForeignKey(p => p.UsuarioId)
    .OnDelete(DeleteBehavior.Cascade); // ğŸ’¡ Sugerido: Elimina los pedidos al borrar un usuario

---

ğŸ”¸ 2. Uno a Uno (One-to-One)

ğŸ“Œ DescripciÃ³n: Un registro en una tabla se relaciona con exactamente un registro en otra.

ğŸ“¦ Ejemplo: Un Usuario tiene un Perfil.

ğŸ“Š Esquema:

Usuarios
--------
Id (PK)
Nombre

Perfiles
--------
UsuarioId (PK, FK)
DirecciÃ³n

âš™ï¸ ConfiguraciÃ³n EF Core:

modelBuilder.Entity<Usuario>()
    .HasOne(u => u.Perfil)
    .WithOne(p => p.Usuario)
    .HasForeignKey<Perfil>(p => p.UsuarioId)
    .OnDelete(DeleteBehavior.Cascade); // ğŸ’¡ Borra el perfil al eliminar el usuario

ğŸ”¸ Nota: EF Core requiere que la clave primaria del dependiente (Perfil) sea tambiÃ©n la FK.

---

ğŸ”¶ 3. Muchos a Muchos (Many-to-Many)

ğŸ“Œ DescripciÃ³n: MÃºltiples registros en una tabla se relacionan con mÃºltiples registros en otra.

ğŸ“¦ Ejemplo: Un Pedido puede tener muchos Productos y un Producto puede estar en muchos Pedidos.

---

âœ… OpciÃ³n 1: ImplÃ­cita (sin entidad intermedia)

ğŸ§± Solo relaciones, sin campos adicionales (como cantidad, precio, etc.)

ğŸ“Š Esquema:

Pedidos
-------
Id (PK)
Fecha

Productos
---------
Id (PK)
Nombre

PedidoProductos (Tabla de uniÃ³n implÃ­cita)
---------------
PedidoId (PK, FK)
ProductoId (PK, FK)

âš™ï¸ ConfiguraciÃ³n EF Core:

modelBuilder.Entity<Pedido>()
    .HasMany(p => p.Productos)
    .WithMany(pr => pr.Pedidos)
    .UsingEntity<Dictionary<string, object>>(
        "PedidoProductos", // Nombre tabla intermedia
        j => j.HasOne<Producto>().WithMany().HasForeignKey("ProductoId"),
        j => j.HasOne<Pedido>().WithMany().HasForeignKey("PedidoId"),
        j => j.HasKey("PedidoId", "ProductoId")
    );

ğŸ’¡ Ãštil cuando no necesitas campos extra en la tabla de relaciÃ³n.

---

âœ… OpciÃ³n 2: ExplÃ­cita (con clase intermedia)

ğŸ§± Permite agregar campos adicionales (cantidad, precio unitario, etc.)

ğŸ“Š Esquema:

public class PedidoProducto
{
    public int PedidoId { get; set; }
    public Pedido Pedido { get; set; }

    public int ProductoId { get; set; }
    public Producto Producto { get; set; }

    public int Cantidad { get; set; } // âœ… Campo adicional
}

âš™ï¸ ConfiguraciÃ³n EF Core:

modelBuilder.Entity<PedidoProducto>()
    .HasKey(pp => new { pp.PedidoId, pp.ProductoId });

modelBuilder.Entity<PedidoProducto>()
    .HasOne(pp => pp.Pedido)
    .WithMany(p => p.PedidoProductos)
    .HasForeignKey(pp => pp.PedidoId);

modelBuilder.Entity<PedidoProducto>()
    .HasOne(pp => pp.Producto)
    .WithMany(p => p.PedidoProductos)
    .HasForeignKey(pp => pp.ProductoId);

ğŸ“ En Pedido y Producto:

public ICollection<PedidoProducto> PedidoProductos { get; set; } = new List<PedidoProducto>();

ğŸ” CuÃ¡ndo usar esta opciÃ³n:
- Necesitas campos como Cantidad, PrecioUnitario, FechaAsignaciÃ³n.
- Qu
